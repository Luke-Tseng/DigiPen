1.
[0, 0, 0, 0, 0, 0, 0, 0, 0]
[0, 0, 0, 5, 5, 5, 5, 5, 5]
[0, 0, 0, 5, 5, 5, 5, 5, 9]
[0, 0, 0, 5, 5, 5, 5, 10, 10]
[0, 0, 2, 5, 5, 7, 7, 10, 10]
[0, 2, 2, 5, 7, 7, 9, 10, 12]
resulting items: [(2, 1), (5, 4), (5, 3)]

2.
create a set to store unconnected dots
for each white dot
    find the closest black dot that isn't in set
        add distance to total length
        add black dot to set
return total length

3.
base case 0 = 0, 1 = 1, 2 = 2, 3 = 4
sum(n) = sum(n-1) + sum(n-2) + sum(n-3) for n > 3

4.
base case
if left = right
    return 1

mid = (left + right) / 2

find the length of the longest subarray in each half
leftLength = recursive call from left to mid
rightLength = recursive call from mid to right

check if the middle element of the two halves are equal
if equal, calculate the length of the subarray that spans both halves
return calculated length
if not equal, return the maximum length of the two halves


5.
Budget constraint at Hickory plant: 150x + 200y <= 45000
Budget constraint at Lenoir plant: 135s + 180t <= 36000
Regular sofa constraint: x + s <= 250
Long sofa constraint: y + t <= 350

Find: Maximum profit = 50x + 70y + 50s + 70t

6.
bool[n + 1][X + 1] table

Base cases
for i in range(n)
    table[i][0] = true
for j in range(X)
    table[0][j] = false

fill table
for i in range(1,n)
    for j in range(1,X)
        if set[i - 1] <= j
            table[i][j] = table[i - 1][j] || table[i - 1][j - set[i - 1]]
        else
            table[i][j] = table[i - 1][j]

return table[n][X]


7.
left = min of first element of both arrays
right = max of last element of both arrays

while left <= right:
    mid = (left + right) / 2.
    count1 = number of elements in array1 <= mid
    count1 = number of elements in array2 <= mid
    if count1 + count2 < k, left = mid + 1
    if count1 + count2 >= k, result = mid and right = mid - 1
return result

8.
initialize distance matrix for each pair of locations and set unreachable locations to infinity

find the min distances between all pairs
for k in range(n):
    for i in range(n):
        for j in range(n):
            distances[i][j] = min(distances[i][j], distances[i][k] + distances[k][j])

find max distance in distance matrix
for i in range(n):
    for j in range(n):
        if distances[i][j] = infinity, return
        minRange = max(minRange, distances[i][j])

return minRange